# 07 测试与部署计划

## 文档信息
- **版本**: v1.0
- **创建日期**: 2024年
- **关联文档**: [MVP开发总体规划](./01_MVP开发总体规划.md)

---

## 1. 测试策略总览

### 1.1 测试金字塔

```
                    ┌─────────┐
                    │  E2E   │  5%  - 关键用户流程
                   ─┼─────────┼─
                  ┌─┴─────────┴─┐
                  │  集成测试   │  15% - API/服务间
                 ─┼─────────────┼─
               ┌──┴─────────────┴──┐
               │     单元测试      │  80% - 核心逻辑
               └───────────────────┘
```

### 1.2 测试覆盖率目标

| 模块 | 单元测试 | 集成测试 | 说明 |
|------|----------|----------|------|
| 领域层 (domain) | ≥90% | - | 核心业务逻辑 |
| 应用层 (application) | ≥80% | ≥70% | 用例编排 |
| 基础设施层 (infrastructure) | ≥60% | ≥80% | DB/缓存操作 |
| API层 (interfaces) | - | ≥90% | 接口契约 |
| 前端组件 | ≥70% | - | 关键交互逻辑 |

---

## 2. 后端测试规范

### 2.1 单元测试

#### 2.1.1 测试文件组织

```
internal/
├── domain/
│   ├── skillcard/
│   │   ├── entity.go
│   │   ├── entity_test.go      # 实体测试
│   │   ├── service.go
│   │   └── service_test.go     # 领域服务测试
│   └── employee/
│       ├── entity.go
│       ├── entity_test.go
│       └── ...
├── application/
│   ├── skillcard/
│   │   ├── usecase.go
│   │   └── usecase_test.go     # 用例测试
│   └── ...
└── infrastructure/
    └── persistence/
        ├── skillcard_repo.go
        └── skillcard_repo_test.go  # 仓储集成测试
```

#### 2.1.2 测试代码示例

```go
// internal/domain/skillcard/entity_test.go
package skillcard

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestSkillCard_Validate(t *testing.T) {
    tests := []struct {
        name    string
        card    *SkillCard
        wantErr bool
        errMsg  string
    }{
        {
            name: "valid skill card",
            card: &SkillCard{
                Name:       "热点分析器",
                Category:   CategoryResearch,
                KernelType: KernelTypeAIModel,
                KernelConfig: &AIModelKernelConfig{
                    Provider: "openai",
                    Model:    "gpt-4",
                },
            },
            wantErr: false,
        },
        {
            name: "empty name",
            card: &SkillCard{
                Name:     "",
                Category: CategoryResearch,
            },
            wantErr: true,
            errMsg:  "skill card name is required",
        },
        {
            name: "invalid category",
            card: &SkillCard{
                Name:     "测试技能",
                Category: "invalid",
            },
            wantErr: true,
            errMsg:  "invalid skill category",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.card.Validate()
            if tt.wantErr {
                require.Error(t, err)
                assert.Contains(t, err.Error(), tt.errMsg)
            } else {
                require.NoError(t, err)
            }
        })
    }
}

func TestSkillCard_Execute(t *testing.T) {
    t.Run("successful execution", func(t *testing.T) {
        card := NewSkillCard("测试技能", CategoryResearch)
        card.KernelType = KernelTypeCodeLogic
        card.KernelConfig = &CodeLogicKernelConfig{
            Language: "javascript",
            Code:     "return { result: input.value * 2 };",
        }

        input := map[string]interface{}{"value": 10}
        output, err := card.Execute(context.Background(), input)

        require.NoError(t, err)
        assert.Equal(t, float64(20), output["result"])
    })
}
```

#### 2.1.3 Mock 使用规范

```go
// internal/application/skillcard/usecase_test.go
package skillcard

import (
    "testing"
    "github.com/stretchr/testify/mock"
    "unlimited-corp/internal/domain/skillcard"
)

// MockSkillCardRepository 模拟仓储
type MockSkillCardRepository struct {
    mock.Mock
}

func (m *MockSkillCardRepository) FindByID(ctx context.Context, id string) (*skillcard.SkillCard, error) {
    args := m.Called(ctx, id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*skillcard.SkillCard), args.Error(1)
}

func (m *MockSkillCardRepository) Save(ctx context.Context, card *skillcard.SkillCard) error {
    args := m.Called(ctx, card)
    return args.Error(0)
}

func TestCreateSkillCardUseCase(t *testing.T) {
    t.Run("create skill card successfully", func(t *testing.T) {
        // Arrange
        mockRepo := new(MockSkillCardRepository)
        mockRepo.On("Save", mock.Anything, mock.AnythingOfType("*skillcard.SkillCard")).
            Return(nil)

        usecase := NewCreateSkillCardUseCase(mockRepo)
        input := CreateSkillCardInput{
            Name:     "新技能卡",
            Category: "research",
        }

        // Act
        output, err := usecase.Execute(context.Background(), input)

        // Assert
        require.NoError(t, err)
        assert.NotEmpty(t, output.ID)
        mockRepo.AssertExpectations(t)
    })
}
```

### 2.2 集成测试

#### 2.2.1 数据库集成测试

```go
// internal/infrastructure/persistence/skillcard_repo_integration_test.go
//go:build integration

package persistence

import (
    "testing"
    "github.com/stretchr/testify/suite"
    "unlimited-corp/internal/infrastructure/database"
)

type SkillCardRepoIntegrationSuite struct {
    suite.Suite
    db   *database.DB
    repo *PostgresSkillCardRepository
}

func (s *SkillCardRepoIntegrationSuite) SetupSuite() {
    // 使用测试数据库
    s.db = database.NewTestDB()
    s.repo = NewPostgresSkillCardRepository(s.db)
}

func (s *SkillCardRepoIntegrationSuite) TearDownSuite() {
    s.db.Close()
}

func (s *SkillCardRepoIntegrationSuite) SetupTest() {
    // 每个测试前清理数据
    s.db.Exec("TRUNCATE TABLE skill_cards CASCADE")
}

func (s *SkillCardRepoIntegrationSuite) TestSaveAndFindByID() {
    card := &skillcard.SkillCard{
        ID:       "test-id-123",
        Name:     "测试技能",
        Category: skillcard.CategoryResearch,
    }

    // Save
    err := s.repo.Save(context.Background(), card)
    s.Require().NoError(err)

    // Find
    found, err := s.repo.FindByID(context.Background(), card.ID)
    s.Require().NoError(err)
    s.Equal(card.Name, found.Name)
    s.Equal(card.Category, found.Category)
}

func TestSkillCardRepoIntegration(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }
    suite.Run(t, new(SkillCardRepoIntegrationSuite))
}
```

#### 2.2.2 API集成测试

```go
// internal/interfaces/http/api/skillcard_handler_test.go
//go:build integration

package api

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
)

func TestSkillCardAPI_Integration(t *testing.T) {
    // Setup
    gin.SetMode(gin.TestMode)
    router := setupTestRouter()

    t.Run("POST /api/v1/skill-cards", func(t *testing.T) {
        body := map[string]interface{}{
            "name":        "测试技能卡",
            "category":    "research",
            "kernel_type": "ai_model",
            "kernel_config": map[string]interface{}{
                "provider": "openai",
                "model":    "gpt-4",
            },
        }
        jsonBody, _ := json.Marshal(body)

        req := httptest.NewRequest(http.MethodPost, "/api/v1/skill-cards", bytes.NewBuffer(jsonBody))
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+getTestToken())

        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)

        assert.Equal(t, http.StatusCreated, w.Code)

        var resp map[string]interface{}
        json.Unmarshal(w.Body.Bytes(), &resp)
        assert.NotEmpty(t, resp["data"].(map[string]interface{})["id"])
    })

    t.Run("GET /api/v1/skill-cards/:id", func(t *testing.T) {
        // 先创建一个技能卡
        cardID := createTestSkillCard(router)

        req := httptest.NewRequest(http.MethodGet, "/api/v1/skill-cards/"+cardID, nil)
        req.Header.Set("Authorization", "Bearer "+getTestToken())

        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)

        assert.Equal(t, http.StatusOK, w.Code)
    })
}
```

### 2.3 Workflow 测试

```go
// internal/workflow/task_workflow_test.go
package workflow

import (
    "testing"
    "go.temporal.io/sdk/testsuite"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/suite"
)

type TaskWorkflowTestSuite struct {
    suite.Suite
    testsuite.WorkflowTestSuite
    env *testsuite.TestWorkflowEnvironment
}

func (s *TaskWorkflowTestSuite) SetupTest() {
    s.env = s.NewTestWorkflowEnvironment()
}

func (s *TaskWorkflowTestSuite) TearDownTest() {
    s.env.AssertExpectations(s.T())
}

func (s *TaskWorkflowTestSuite) TestTaskWorkflow_Success() {
    // Mock Activities
    s.env.OnActivity(ScheduleEmployeeActivity, mock.Anything, mock.Anything).
        Return(&ScheduleResult{EmployeeID: "emp-1"}, nil)

    s.env.OnActivity(ExecuteStepActivity, mock.Anything, mock.Anything).
        Return(&StepOutput{Success: true, Data: map[string]interface{}{"result": "ok"}}, nil)

    s.env.OnActivity(UpdateTaskStatusActivity, mock.Anything, mock.Anything).
        Return(nil)

    // Execute Workflow
    input := TaskWorkflowInput{
        TaskID:      "task-123",
        WorkflowDef: createTestWorkflowDef(),
    }

    s.env.ExecuteWorkflow(TaskWorkflow, input)

    s.True(s.env.IsWorkflowCompleted())
    s.NoError(s.env.GetWorkflowError())

    var result TaskWorkflowOutput
    s.NoError(s.env.GetWorkflowResult(&result))
    s.Equal("completed", result.Status)
}

func (s *TaskWorkflowTestSuite) TestTaskWorkflow_StepFailure_Retry() {
    // 第一次失败，第二次成功
    s.env.OnActivity(ExecuteStepActivity, mock.Anything, mock.Anything).
        Return(nil, errors.New("temporary error")).Once()
    s.env.OnActivity(ExecuteStepActivity, mock.Anything, mock.Anything).
        Return(&StepOutput{Success: true}, nil).Once()

    // ... 其他mock

    s.env.ExecuteWorkflow(TaskWorkflow, input)

    s.True(s.env.IsWorkflowCompleted())
    s.NoError(s.env.GetWorkflowError())
}

func TestTaskWorkflowTestSuite(t *testing.T) {
    suite.Run(t, new(TaskWorkflowTestSuite))
}
```

---

## 3. 前端测试规范

### 3.1 组件单元测试

```tsx
// src/components/EmployeeCard/__tests__/EmployeeCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { EmployeeCard } from '../EmployeeCard';
import { Employee, EmployeeStatus } from '@/types/employee';

describe('EmployeeCard', () => {
  const mockEmployee: Employee = {
    id: 'emp-1',
    name: '小助手',
    role: '研究员',
    avatar: '/avatars/assistant.png',
    status: EmployeeStatus.IDLE,
    skillCards: [
      { id: 'skill-1', name: '热点分析' },
    ],
    stats: {
      totalTasks: 100,
      successRate: 0.95,
    },
  };

  it('renders employee name and role', () => {
    render(<EmployeeCard employee={mockEmployee} />);
    
    expect(screen.getByText('小助手')).toBeInTheDocument();
    expect(screen.getByText('研究员')).toBeInTheDocument();
  });

  it('shows idle status badge', () => {
    render(<EmployeeCard employee={mockEmployee} />);
    
    expect(screen.getByText('空闲')).toBeInTheDocument();
  });

  it('shows working status when busy', () => {
    const busyEmployee = {
      ...mockEmployee,
      status: EmployeeStatus.WORKING,
      currentTask: { id: 'task-1', name: '分析热点' },
    };
    
    render(<EmployeeCard employee={busyEmployee} />);
    
    expect(screen.getByText('工作中')).toBeInTheDocument();
    expect(screen.getByText('分析热点')).toBeInTheDocument();
  });

  it('calls onViewDetail when clicked', () => {
    const onViewDetail = jest.fn();
    render(<EmployeeCard employee={mockEmployee} onViewDetail={onViewDetail} />);
    
    fireEvent.click(screen.getByRole('button', { name: /查看详情/i }));
    
    expect(onViewDetail).toHaveBeenCalledWith('emp-1');
  });

  it('displays skill cards', () => {
    render(<EmployeeCard employee={mockEmployee} />);
    
    expect(screen.getByText('热点分析')).toBeInTheDocument();
  });
});
```

### 3.2 Hook 测试

```tsx
// src/hooks/__tests__/useSecretaryChat.test.ts
import { renderHook, act, waitFor } from '@testing-library/react';
import { useSecretaryChat } from '../useSecretaryChat';
import { secretaryApi } from '@/api/secretary';

jest.mock('@/api/secretary');

describe('useSecretaryChat', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('sends message and receives response', async () => {
    const mockResponse = {
      data: {
        response: {
          text: '好的，我来帮您安排任务',
          actions: [{ type: 'create_task', data: { name: '新任务' } }],
        },
      },
    };
    (secretaryApi.sendCommand as jest.Mock).mockResolvedValue(mockResponse);

    const { result } = renderHook(() => useSecretaryChat());

    act(() => {
      result.current.sendMessage('创建一个新任务');
    });

    await waitFor(() => {
      expect(result.current.messages).toHaveLength(2);
    });

    expect(result.current.messages[0].content).toBe('创建一个新任务');
    expect(result.current.messages[1].content).toBe('好的，我来帮您安排任务');
    expect(result.current.messages[1].actions).toHaveLength(1);
  });

  it('handles error gracefully', async () => {
    (secretaryApi.sendCommand as jest.Mock).mockRejectedValue(new Error('Network error'));

    const { result } = renderHook(() => useSecretaryChat());

    act(() => {
      result.current.sendMessage('测试消息');
    });

    await waitFor(() => {
      expect(result.current.error).toBe('发送失败，请重试');
    });
  });
});
```

### 3.3 Store 测试

```tsx
// src/store/__tests__/taskStore.test.ts
import { useTaskStore } from '../taskStore';
import { TaskStatus } from '@/types/task';

describe('TaskStore', () => {
  beforeEach(() => {
    useTaskStore.setState({ tasks: [], loading: false, error: null });
  });

  it('adds a new task', () => {
    const { addTask } = useTaskStore.getState();
    
    addTask({
      id: 'task-1',
      title: '测试任务',
      status: TaskStatus.PENDING,
    });

    const { tasks } = useTaskStore.getState();
    expect(tasks).toHaveLength(1);
    expect(tasks[0].title).toBe('测试任务');
  });

  it('updates task status', () => {
    useTaskStore.setState({
      tasks: [{ id: 'task-1', title: '任务', status: TaskStatus.PENDING }],
    });

    const { updateTaskStatus } = useTaskStore.getState();
    updateTaskStatus('task-1', TaskStatus.IN_PROGRESS);

    const { tasks } = useTaskStore.getState();
    expect(tasks[0].status).toBe(TaskStatus.IN_PROGRESS);
  });

  it('filters tasks by status', () => {
    useTaskStore.setState({
      tasks: [
        { id: '1', title: '待处理', status: TaskStatus.PENDING },
        { id: '2', title: '进行中', status: TaskStatus.IN_PROGRESS },
        { id: '3', title: '已完成', status: TaskStatus.COMPLETED },
      ],
    });

    const pendingTasks = useTaskStore.getState().getTasksByStatus(TaskStatus.PENDING);
    expect(pendingTasks).toHaveLength(1);
    expect(pendingTasks[0].title).toBe('待处理');
  });
});
```

### 3.4 E2E 测试 (Playwright)

```typescript
// e2e/secretary-chat.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Secretary Chat', () => {
  test.beforeEach(async ({ page }) => {
    // 登录
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('/dashboard');
  });

  test('can send message and receive response', async ({ page }) => {
    // 打开秘书对话面板
    await page.click('[data-testid="secretary-button"]');
    
    // 发送消息
    await page.fill('[data-testid="chat-input"]', '帮我创建一个热点分析任务');
    await page.click('[data-testid="send-button"]');

    // 验证消息显示
    await expect(page.locator('[data-testid="user-message"]')).toContainText('帮我创建一个热点分析任务');
    
    // 等待AI响应
    await expect(page.locator('[data-testid="assistant-message"]')).toBeVisible({ timeout: 10000 });
  });

  test('can create task through secretary', async ({ page }) => {
    await page.click('[data-testid="secretary-button"]');
    await page.fill('[data-testid="chat-input"]', '创建任务：分析今日热点');
    await page.click('[data-testid="send-button"]');

    // 等待任务创建确认
    await expect(page.locator('[data-testid="action-card"]')).toBeVisible();
    await page.click('[data-testid="confirm-action"]');

    // 验证任务出现在任务列表
    await page.click('[data-testid="tasks-tab"]');
    await expect(page.locator('[data-testid="task-card"]')).toContainText('分析今日热点');
  });
});
```

---

## 4. 测试执行

### 4.1 本地测试命令

```bash
# 后端测试
# 运行所有单元测试
go test ./... -short -v

# 运行特定包测试
go test ./internal/domain/... -v

# 运行集成测试
go test ./... -tags=integration -v

# 生成覆盖率报告
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html

# 前端测试
# 运行单元测试
npm test

# 监听模式
npm test -- --watch

# 覆盖率报告
npm test -- --coverage

# E2E测试
npx playwright test

# E2E测试（带UI）
npx playwright test --ui
```

### 4.2 CI/CD 测试配置

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  backend-test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: unlimited_corp_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
      
      - name: Run Unit Tests
        run: go test ./... -short -v -race
      
      - name: Run Integration Tests
        run: go test ./... -tags=integration -v
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          REDIS_HOST: localhost
          REDIS_PORT: 6379
      
      - name: Generate Coverage
        run: |
          go test ./... -coverprofile=coverage.out
          go tool cover -func=coverage.out

  frontend-test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install Dependencies
        run: npm ci
        working-directory: frontend
      
      - name: Run Tests
        run: npm test -- --coverage --watchAll=false
        working-directory: frontend
      
      - name: Upload Coverage
        uses: codecov/codecov-action@v3
        with:
          files: frontend/coverage/lcov.info

  e2e-test:
    runs-on: ubuntu-latest
    needs: [backend-test, frontend-test]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install Dependencies
        run: npm ci
        working-directory: frontend
      
      - name: Install Playwright
        run: npx playwright install --with-deps
        working-directory: frontend
      
      - name: Start Services
        run: docker-compose up -d
      
      - name: Run E2E Tests
        run: npx playwright test
        working-directory: frontend
      
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: frontend/playwright-report/
```

---

## 5. 部署规范

### 5.1 部署架构

```
                         ┌─────────────────┐
                         │   Cloudflare    │
                         │     (CDN)       │
                         └────────┬────────┘
                                  │
                         ┌────────▼────────┐
                         │   Nginx/Caddy   │
                         │  (反向代理/TLS) │
                         └────────┬────────┘
                                  │
              ┌───────────────────┼───────────────────┐
              │                   │                   │
     ┌────────▼────────┐ ┌────────▼────────┐ ┌────────▼────────┐
     │   前端静态资源   │ │    API Server   │ │  WebSocket      │
     │   (Vite Build)  │ │   (Go + Gin)    │ │   Server        │
     └─────────────────┘ └────────┬────────┘ └─────────────────┘
                                  │
         ┌───────────────────┬────┴────┬───────────────────┐
         │                   │         │                   │
┌────────▼────────┐ ┌────────▼────────┐│ ┌────────▼────────┐
│   PostgreSQL    │ │      Redis      ││ │    Temporal     │
│   (Primary)     │ │    (Cache)      ││ │   (Workflow)    │
└─────────────────┘ └─────────────────┘│ └─────────────────┘
                                       │
                              ┌────────▼────────┐
                              │      Kafka      │
                              │   (事件总线)    │
                              └─────────────────┘
```

### 5.2 Docker 镜像构建

#### 5.2.1 后端 Dockerfile

```dockerfile
# Dockerfile.backend
# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app

# 安装必要工具
RUN apk add --no-cache git ca-certificates

# 下载依赖
COPY go.mod go.sum ./
RUN go mod download

# 构建
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o /server ./cmd/server

# Runtime stage
FROM alpine:3.19

WORKDIR /app

# 安装运行时依赖
RUN apk add --no-cache ca-certificates tzdata

# 复制二进制
COPY --from=builder /server .
COPY --from=builder /app/configs ./configs

# 创建非root用户
RUN adduser -D -g '' appuser
USER appuser

EXPOSE 8080

ENTRYPOINT ["./server"]
```

#### 5.2.2 前端 Dockerfile

```dockerfile
# Dockerfile.frontend
# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

# Runtime stage
FROM nginx:alpine

COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### 5.3 Docker Compose 生产配置

```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  # 反向代理
  caddy:
    image: caddy:2-alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
      - caddy_config:/config
    depends_on:
      - backend
      - frontend
    restart: unless-stopped

  # 前端
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    restart: unless-stopped

  # 后端 API
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      - ENV=production
      - DB_HOST=postgres
      - DB_PORT=5432
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - KAFKA_BROKERS=kafka:9092
      - TEMPORAL_HOST=temporal:7233
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      kafka:
        condition: service_healthy
    restart: unless-stopped
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '1'
          memory: 1G

  # Temporal Worker
  worker:
    build:
      context: ./backend
      dockerfile: Dockerfile.worker
    environment:
      - ENV=production
      - TEMPORAL_HOST=temporal:7233
    depends_on:
      - temporal
    restart: unless-stopped
    deploy:
      replicas: 2

  # 数据库
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: unlimited_corp
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # 缓存
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # 消息队列
  kafka:
    image: confluentinc/cp-kafka:7.5.0
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092
      KAFKA_AUTO_CREATE_TOPICS_ENABLE: 'false'
    volumes:
      - kafka_data:/var/lib/kafka/data
    depends_on:
      - zookeeper
    healthcheck:
      test: ["CMD", "kafka-broker-api-versions", "--bootstrap-server", "localhost:9092"]
      interval: 10s
      timeout: 10s
      retries: 5
    restart: unless-stopped

  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
    volumes:
      - zookeeper_data:/var/lib/zookeeper/data
    restart: unless-stopped

  # Temporal
  temporal:
    image: temporalio/auto-setup:1.22
    environment:
      - DB=postgresql
      - DB_PORT=5432
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PWD=${DB_PASSWORD}
      - POSTGRES_SEEDS=postgres
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  kafka_data:
  zookeeper_data:
  caddy_data:
  caddy_config:
```

### 5.4 Caddy 配置

```
# Caddyfile
{
    email admin@unlimited-corp.com
}

unlimited-corp.com {
    # 前端静态资源
    handle /assets/* {
        reverse_proxy frontend:80
    }

    handle / {
        reverse_proxy frontend:80
    }

    # API 代理
    handle /api/* {
        reverse_proxy backend:8080
    }

    # WebSocket
    handle /ws/* {
        reverse_proxy backend:8080
    }

    # 压缩
    encode gzip

    # 日志
    log {
        output file /var/log/caddy/access.log
    }
}
```

---

## 6. 环境配置

### 6.1 环境变量模板

```bash
# .env.example
# ========== 应用配置 ==========
ENV=development
APP_NAME=unlimited-corp
APP_PORT=8080

# ========== 数据库 ==========
DB_HOST=localhost
DB_PORT=5432
DB_USER=unlimited
DB_PASSWORD=your_password
DB_NAME=unlimited_corp
DB_SSL_MODE=disable

# ========== Redis ==========
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=your_redis_password
REDIS_DB=0

# ========== Kafka ==========
KAFKA_BROKERS=localhost:9092

# ========== Temporal ==========
TEMPORAL_HOST=localhost:7233
TEMPORAL_NAMESPACE=unlimited-corp

# ========== JWT ==========
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRES_IN=24h

# ========== AI Provider ==========
OPENAI_API_KEY=sk-...
OPENAI_BASE_URL=https://api.openai.com/v1

# ========== MinIO ==========
MINIO_ENDPOINT=localhost:9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_BUCKET=unlimited-corp

# ========== 日志 ==========
LOG_LEVEL=debug
LOG_FORMAT=json
```

### 6.2 配置文件结构

```yaml
# configs/config.yaml
app:
  name: unlimited-corp
  port: 8080
  mode: ${ENV:development}

database:
  host: ${DB_HOST:localhost}
  port: ${DB_PORT:5432}
  user: ${DB_USER:unlimited}
  password: ${DB_PASSWORD}
  name: ${DB_NAME:unlimited_corp}
  pool:
    max_open: 25
    max_idle: 5
    max_lifetime: 5m

redis:
  host: ${REDIS_HOST:localhost}
  port: ${REDIS_PORT:6379}
  password: ${REDIS_PASSWORD}
  db: ${REDIS_DB:0}
  pool_size: 10

kafka:
  brokers:
    - ${KAFKA_BROKERS:localhost:9092}
  topics:
    task_events: unlimited.task.events
    employee_events: unlimited.employee.events

temporal:
  host: ${TEMPORAL_HOST:localhost:7233}
  namespace: ${TEMPORAL_NAMESPACE:unlimited-corp}
  task_queue: unlimited-task-queue

jwt:
  secret: ${JWT_SECRET}
  expires_in: ${JWT_EXPIRES_IN:24h}

ai:
  openai:
    api_key: ${OPENAI_API_KEY}
    base_url: ${OPENAI_BASE_URL:https://api.openai.com/v1}
    default_model: gpt-4

logging:
  level: ${LOG_LEVEL:info}
  format: ${LOG_FORMAT:json}
```

---

## 7. 监控与告警

### 7.1 健康检查端点

```go
// internal/interfaces/http/health.go
package http

func RegisterHealthRoutes(r *gin.Engine) {
    r.GET("/health", healthCheck)
    r.GET("/health/ready", readinessCheck)
    r.GET("/health/live", livenessCheck)
}

func healthCheck(c *gin.Context) {
    c.JSON(200, gin.H{
        "status": "healthy",
        "time":   time.Now().UTC(),
    })
}

func readinessCheck(c *gin.Context) {
    // 检查数据库连接
    if err := db.Ping(); err != nil {
        c.JSON(503, gin.H{"status": "not ready", "error": "database"})
        return
    }
    
    // 检查Redis连接
    if err := redis.Ping(context.Background()).Err(); err != nil {
        c.JSON(503, gin.H{"status": "not ready", "error": "redis"})
        return
    }
    
    c.JSON(200, gin.H{"status": "ready"})
}

func livenessCheck(c *gin.Context) {
    c.JSON(200, gin.H{"status": "alive"})
}
```

### 7.2 Prometheus 指标

```go
// internal/infrastructure/metrics/prometheus.go
package metrics

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    HttpRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "path", "status"},
    )

    HttpRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "path"},
    )

    TaskExecutionTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "task_execution_total",
            Help: "Total number of task executions",
        },
        []string{"status"},
    )

    TaskExecutionDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "task_execution_duration_seconds",
            Help:    "Task execution duration in seconds",
            Buckets: []float64{1, 5, 10, 30, 60, 120, 300},
        },
        []string{"skill_type"},
    )

    EmployeeWorkload = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "employee_workload",
            Help: "Current workload of employees",
        },
        []string{"employee_id"},
    )
)
```

---

## 8. 部署检查清单

### 8.1 上线前检查

| 检查项 | 描述 | 状态 |
|--------|------|------|
| 单元测试通过 | 所有单元测试100%通过 | ☐ |
| 集成测试通过 | 所有集成测试通过 | ☐ |
| E2E测试通过 | 关键流程E2E测试通过 | ☐ |
| 代码审查完成 | PR已审查并批准 | ☐ |
| 安全扫描通过 | 无高危漏洞 | ☐ |
| 环境变量配置 | 生产环境变量已配置 | ☐ |
| 数据库迁移 | 迁移脚本已验证 | ☐ |
| 备份策略 | 数据库备份已配置 | ☐ |
| 监控告警 | Prometheus/Grafana已配置 | ☐ |
| 日志收集 | 日志聚合已配置 | ☐ |
| SSL证书 | HTTPS证书已部署 | ☐ |
| CDN配置 | 静态资源CDN已配置 | ☐ |

### 8.2 回滚计划

```bash
#!/bin/bash
# scripts/rollback.sh

# 获取上一个版本
PREVIOUS_VERSION=$(git describe --tags --abbrev=0 HEAD^)

echo "Rolling back to version: $PREVIOUS_VERSION"

# 切换到上一个版本
git checkout $PREVIOUS_VERSION

# 重新构建并部署
docker-compose -f docker-compose.prod.yml build
docker-compose -f docker-compose.prod.yml up -d

# 验证服务健康
sleep 30
curl -f http://localhost/health || {
    echo "Health check failed after rollback!"
    exit 1
}

echo "Rollback completed successfully"
```

---

## 9. 文档修订历史

| 版本 | 日期 | 修改内容 | 作者 |
|------|------|----------|------|
| v1.0 | - | 初始版本 | AI助手 |
