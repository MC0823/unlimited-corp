# M3+M4执行技术方案

**文档版本**: 1.0  
**编写时间**: 2025-12-08  
**关联文档**: 04_现状分析与后续执行方案.md

---

## 一、M3阶段技术方案（工作流引擎）

### 1.1 Temporal集成方案

#### 环境部署

```bash
# docker-compose.yaml 新增
services:
  temporal:
    image: temporalio/auto-setup:latest
    environment:
      - DB=postgresql
      - DB_PORT=5432
      - POSTGRES_USER=unlimited
      - POSTGRES_PWD=your_password
      - POSTGRES_SEEDS=postgres
    ports:
      - "7233:7233"  # gRPC
    depends_on:
      - postgres

  temporal-ui:
    image: temporalio/ui:latest
    ports:
      - "8080:8080"
    environment:
      - TEMPORAL_ADDRESS=temporal:7233
    depends_on:
      - temporal
```

#### Go应用集成

```go
// backend/internal/infrastructure/temporal/client.go
package temporal

import (
    "context"
    "go.temporal.io/sdk/client"
)

type TemporalClient struct {
    client client.Client
}

func NewTemporalClient(ctx context.Context) (*TemporalClient, error) {
    c, err := client.Dial(client.Options{
        HostPort: "localhost:7233",
    })
    if err != nil {
        return nil, err
    }
    return &TemporalClient{client: c}, nil
}

func (tc *TemporalClient) Close() {
    tc.client.Close()
}
```

#### 工作流定义

```go
// backend/internal/workflow/workflow.go
package workflow

import (
    "go.temporal.io/sdk/workflow"
    "context"
)

// 内容创作工作流
func ContentCreationWorkflow(ctx workflow.Context, input WorkflowInput) (*WorkflowResult, error) {
    // 第一步：热点分析
    var hotspotResult HotspotAnalysisResult
    err := workflow.ExecuteActivity(
        ctx,
        ActivityHotspotAnalysis,
        input.Topic,
    ).Get(ctx, &hotspotResult)
    if err != nil {
        return nil, err
    }
    
    // 第二步：文案生成
    var contentResult ContentGenerationResult
    err = workflow.ExecuteActivity(
        ctx,
        ActivityContentGeneration,
        hotspotResult,
    ).Get(ctx, &contentResult)
    if err != nil {
        return nil, err
    }
    
    // 第三步：配图生成
    var imageResult ImageGenerationResult
    err = workflow.ExecuteActivity(
        ctx,
        ActivityImageGeneration,
        contentResult,
    ).Get(ctx, &imageResult)
    if err != nil {
        return nil, err
    }
    
    return &WorkflowResult{
        Content: contentResult,
        Images:  imageResult,
    }, nil
}

// Activity定义
func ActivityHotspotAnalysis(ctx context.Context, topic string) (*HotspotAnalysisResult, error) {
    // 调用技能卡执行器
    return nil, nil
}
```

#### 工作流注册

```go
// backend/cmd/server/main.go
import "go.temporal.io/sdk/worker"

func registerWorkflows(w worker.Worker) {
    w.RegisterWorkflow(ContentCreationWorkflow)
    w.RegisterWorkflow(HotspotTrackingWorkflow)
    w.RegisterWorkflow(AutoOpsWorkflow)
    
    w.RegisterActivity(ActivityHotspotAnalysis)
    w.RegisterActivity(ActivityContentGeneration)
    w.RegisterActivity(ActivityImageGeneration)
    // ... 其他Activity
}
```

### 1.2 任务调度算法

#### 调度器设计

```go
// backend/internal/service/scheduler.go
package service

import (
    "context"
    "fmt"
    "sort"
    "backend/internal/domain"
)

type SchedulingScore struct {
    EmployeeID string
    Score      float64
}

type TaskScheduler struct {
    employeeRepo domain.EmployeeRepository
    taskRepo     domain.TaskRepository
    logger       Logger
}

// 调度任务到合适员工
func (s *TaskScheduler) Schedule(ctx context.Context, task *domain.Task) error {
    // 1. 获取所有空闲员工
    employees, err := s.employeeRepo.ListByCompany(ctx, task.CompanyID, &domain.EmployeeFilter{
        Status: domain.StatusIdle,
    })
    if err != nil {
        return err
    }
    
    if len(employees) == 0 {
        // 没有空闲员工，放入队列等待
        return s.taskRepo.UpdateStatus(ctx, task.ID, domain.TaskStatusWaiting)
    }
    
    // 2. 计算匹配度分数
    scores := s.calculateScores(task, employees)
    
    // 3. 选择分数最高的员工
    sort.Slice(scores, func(i, j int) bool {
        return scores[i].Score > scores[j].Score
    })
    
    selectedEmployee := scores[0]
    
    // 4. 更新员工状态和任务
    err = s.employeeRepo.UpdateStatus(ctx, selectedEmployee.EmployeeID, domain.StatusWorking)
    if err != nil {
        return err
    }
    
    task.AssignedEmployeeID = selectedEmployee.EmployeeID
    err = s.taskRepo.Update(ctx, task)
    
    s.logger.Infof("Task %s assigned to employee %s with score %.2f",
        task.ID, selectedEmployee.EmployeeID, selectedEmployee.Score)
    
    return err
}

// 计算员工与任务的匹配度
func (s *TaskScheduler) calculateScores(task *domain.Task, employees []*domain.Employee) []SchedulingScore {
    scores := make([]SchedulingScore, len(employees))
    
    for i, emp := range employees {
        score := 0.0
        
        // 1. 技能匹配度 (权重: 40%)
        skillMatch := s.calculateSkillMatch(task, emp)
        score += skillMatch * 0.4
        
        // 2. 负载均衡 (权重: 30%)
        // 任务数越少，分数越高
        loadBalance := 100.0 / float64(emp.Performance.TodayTasks+1)
        score += loadBalance * 0.3
        
        // 3. 历史成功率 (权重: 20%)
        score += emp.Performance.SuccessRate * 100 * 0.2
        
        // 4. 优先级奖励 (权重: 10%)
        priorityBonus := float64(task.Priority) * 10 // 1-4级别
        score += priorityBonus * 0.1
        
        scores[i] = SchedulingScore{
            EmployeeID: emp.ID,
            Score:      score,
        }
    }
    
    return scores
}

// 计算技能匹配度
func (s *TaskScheduler) calculateSkillMatch(task *domain.Task, emp *domain.Employee) float64 {
    // 如果员工拥有任务所需的技能卡
    if emp.EquippedSkillCardID == task.RequiredSkillCardID {
        return 100.0
    }
    
    // 如果没有装备技能，但可以学习
    return 50.0
}
```

### 1.3 技能执行器

#### AI模型适配层

```go
// backend/internal/service/skill_executor.go
package service

import (
    "context"
    "github.com/sashabaranov/go-openai"
    "backend/internal/domain"
    "time"
)

type SkillExecutor struct {
    aiClients map[string]AIClient  // 多模型支持
    logger    Logger
}

type AIClient interface {
    ChatCompletion(ctx context.Context, req *ChatRequest) (*ChatResponse, error)
}

type OpenAIClient struct {
    client *openai.Client
}

func (c *OpenAIClient) ChatCompletion(ctx context.Context, req *ChatRequest) (*ChatResponse, error) {
    resp, err := c.client.CreateChatCompletion(ctx, openai.ChatCompletionRequest{
        Model:       req.Model,
        Messages:    convertMessages(req.Messages),
        Temperature: req.Temperature,
        MaxTokens:   req.MaxTokens,
    })
    if err != nil {
        return nil, err
    }
    
    return &ChatResponse{
        Content: resp.Choices[0].Message.Content,
        Usage: Usage{
            PromptTokens:   resp.Usage.PromptTokens,
            CompletionTokens: resp.Usage.CompletionTokens,
            TotalTokens:    resp.Usage.TotalTokens,
        },
    }, nil
}

// 执行技能卡
func (e *SkillExecutor) Execute(ctx context.Context, 
    card *domain.SkillCard, 
    input map[string]interface{}) (*ExecutionResult, error) {
    
    start := time.Now()
    
    // 1. 验证输入
    err := e.validateInput(card.InputSchema, input)
    if err != nil {
        return &ExecutionResult{
            Status: ExecutionFailed,
            Error:  err.Error(),
        }, nil
    }
    
    // 2. 获取AI客户端
    client, ok := e.aiClients[card.KernelConfig.ModelID]
    if !ok {
        return nil, fmt.Errorf("unsupported model: %s", card.KernelConfig.ModelID)
    }
    
    // 3. 渲染提示词
    prompt := e.renderPrompt(card.KernelConfig.UserPromptTemplate, input)
    
    // 4. 调用AI API
    resp, err := client.ChatCompletion(ctx, &ChatRequest{
        Model: card.KernelConfig.ModelID,
        Messages: []Message{
            {Role: "system", Content: card.KernelConfig.SystemPrompt},
            {Role: "user", Content: prompt},
        },
        Temperature: card.KernelConfig.Temperature,
        MaxTokens:   card.KernelConfig.MaxTokens,
    })
    if err != nil {
        // 重试机制
        return e.retryExecution(ctx, card, input, err)
    }
    
    // 5. 验证输出
    output, err := e.validateOutput(card.OutputSchema, resp.Content)
    if err != nil {
        return &ExecutionResult{
            Status: ExecutionFailed,
            Error:  fmt.Sprintf("output validation failed: %v", err),
        }, nil
    }
    
    return &ExecutionResult{
        Status:        ExecutionSuccess,
        Output:        output,
        TokensUsed:    resp.Usage.TotalTokens,
        ExecutionTime: time.Since(start).Milliseconds(),
    }, nil
}

// 重试机制
func (e *SkillExecutor) retryExecution(ctx context.Context,
    card *domain.SkillCard,
    input map[string]interface{},
    lastErr error) (*ExecutionResult, error) {
    
    maxRetries := 3
    for i := 0; i < maxRetries; i++ {
        // 指数退避
        backoff := time.Duration(math.Pow(2, float64(i))) * time.Second
        select {
        case <-time.After(backoff):
        case <-ctx.Done():
            return nil, ctx.Err()
        }
        
        // 重新执行
        result, err := e.Execute(ctx, card, input)
        if err == nil {
            return result, nil
        }
    }
    
    return nil, fmt.Errorf("execution failed after %d retries: %w", maxRetries, lastErr)
}
```

#### 输入输出验证

```go
// backend/internal/service/schema_validator.go
package service

import (
    "github.com/xeipuuv/gojsonschema"
)

func (e *SkillExecutor) validateInput(schema map[string]interface{}, 
    data map[string]interface{}) error {
    
    schemaLoader := gojsonschema.NewGoLoader(schema)
    dataLoader := gojsonschema.NewGoLoader(data)
    
    result, err := gojsonschema.Validate(schemaLoader, dataLoader)
    if err != nil {
        return err
    }
    
    if !result.Valid() {
        errors := make([]string, len(result.Errors()))
        for i, err := range result.Errors() {
            errors[i] = err.String()
        }
        return fmt.Errorf("validation errors: %v", errors)
    }
    
    return nil
}

func (e *SkillExecutor) validateOutput(schema map[string]interface{}, 
    output string) (interface{}, error) {
    
    // 先尝试解析为JSON
    var data interface{}
    err := json.Unmarshal([]byte(output), &data)
    if err != nil {
        // 如果不是JSON，作为字符串返回
        data = output
    }
    
    // 验证schema
    err = e.validateInput(schema, data)
    return data, err
}
```

### 1.4 事件驱动系统

#### 事件总线实现

```go
// backend/internal/infrastructure/event/bus.go
package event

import (
    "context"
    "sync"
    "fmt"
)

type Event struct {
    Type      string                 `json:"type"`
    Timestamp int64                  `json:"timestamp"`
    Data      map[string]interface{} `json:"data"`
}

type EventHandler func(ctx context.Context, event *Event) error

type EventBus struct {
    handlers map[string][]EventHandler
    mu       sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        handlers: make(map[string][]EventHandler),
    }
}

// 订阅事件
func (eb *EventBus) Subscribe(eventType string, handler EventHandler) {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    
    eb.handlers[eventType] = append(eb.handlers[eventType], handler)
}

// 发布事件
func (eb *EventBus) Publish(ctx context.Context, event *Event) error {
    eb.mu.RLock()
    handlers, ok := eb.handlers[event.Type]
    eb.mu.RUnlock()
    
    if !ok {
        return nil  // 没有订阅者，正常返回
    }
    
    var errs []error
    for _, handler := range handlers {
        if err := handler(ctx, event); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("event handling errors: %v", errs)
    }
    
    return nil
}
```

#### 事件订阅

```go
// backend/internal/application/event_handlers.go
package application

import (
    "context"
    "backend/internal/infrastructure/event"
)

func RegisterEventHandlers(eventBus *event.EventBus, taskService TaskService) {
    // 任务完成事件处理
    eventBus.Subscribe(event.EventTaskCompleted, func(ctx context.Context, e *event.Event) error {
        taskID := e.Data["taskId"].(string)
        
        // 更新任务状态
        task, _ := taskService.GetByID(ctx, taskID)
        task.Status = "completed"
        taskService.Update(ctx, task)
        
        // 发送通知
        // ...
        
        return nil
    })
    
    // 员工状态变化事件处理
    eventBus.Subscribe(event.EventEmployeeStatusChanged, func(ctx context.Context, e *event.Event) error {
        employeeID := e.Data["employeeId"].(string)
        newStatus := e.Data["status"].(string)
        
        // 更新缓存
        // ...
        
        return nil
    })
}
```

---

## 二、M4阶段技术方案（前端整合）

### 2.1 前端项目结构与配置

#### Vite配置

```ts
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    strictPort: false,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path,
      },
      '/ws': {
        target: 'ws://localhost:8080',
        ws: true,
      },
    },
  },
})
```

#### TypeScript配置

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "noEmit": true
  }
}
```

#### Tailwind配置

```js
// tailwind.config.js
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: '#3B82F6',
        dark: {
          900: '#111827',
          800: '#1F2937',
          700: '#374151',
        }
      },
      keyframes: {
        pulse: {
          '0%, 100%': { opacity: '1' },
          '50%': { opacity: '.5' },
        }
      }
    },
  },
  plugins: [],
}
```

### 2.2 API客户端设计

#### Axios拦截器链

```ts
// src/api/client.ts
import axios, { AxiosError, AxiosInstance } from 'axios'
import { useAuthStore } from '@/stores/authStore'
import { useToastStore } from '@/stores/toastStore'

const client: AxiosInstance = axios.create({
  baseURL: '/api/v1',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
})

// 请求拦截器：添加token
client.interceptors.request.use((config) => {
  const token = useAuthStore.getState().accessToken
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  
  // 添加请求ID用于追踪
  config.headers['X-Request-ID'] = crypto.randomUUID()
  
  return config
})

// 响应拦截器：处理错误和token刷新
client.interceptors.response.use(
  (response) => response.data,
  async (error: AxiosError<ApiError>) => {
    const { logout, refreshToken, accessToken } = useAuthStore.getState()
    const { showError } = useToastStore.getState()
    
    // 401 Unauthorized - token过期
    if (error.response?.status === 401) {
      if (accessToken) {
        // 尝试刷新token
        const success = await refreshToken()
        if (success && error.config) {
          return client.request(error.config)
        }
      }
      logout()
      return Promise.reject(new Error('认证失败，请重新登录'))
    }
    
    // 其他错误
    const errorMsg = error.response?.data?.message || error.message
    showError(errorMsg)
    
    return Promise.reject(error)
  }
)

export default client
```

#### 业务API封装

```ts
// src/api/index.ts
export const authApi = {
  register: (data: RegisterRequest) =>
    client.post<AuthResponse>('/auth/register', data),
  
  login: (data: LoginRequest) =>
    client.post<AuthResponse>('/auth/login', data),
  
  refresh: (refreshToken: string) =>
    client.post<TokenPair>('/auth/refresh', { refreshToken }),
}

export const taskApi = {
  list: (params?: TaskFilter) =>
    client.get<TaskListResponse>('/tasks', { params }),
  
  create: (data: CreateTaskRequest) =>
    client.post<Task>('/tasks', data),
  
  getDetail: (id: string) =>
    client.get<Task>(`/tasks/${id}`),
  
  updateStatus: (id: string, status: TaskStatus) =>
    client.patch<Task>(`/tasks/${id}/status`, { status }),
  
  delete: (id: string) =>
    client.delete(`/tasks/${id}`),
}

// 导出所有API
export * from './auth'
export * from './task'
export * from './employee'
export * from './skillcard'
```

### 2.3 状态管理设计

#### 认证状态

```ts
// src/stores/authStore.ts
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { authApi } from '@/api'

interface User {
  id: string
  email: string
  username: string
}

interface AuthState {
  user: User | null
  accessToken: string | null
  refreshToken: string | null
  isAuthenticated: boolean
  isLoading: boolean
  
  // Actions
  login: (email: string, password: string) => Promise<void>
  register: (email: string, password: string, username: string) => Promise<void>
  logout: () => void
  refreshToken: () => Promise<boolean>
  setUser: (user: User) => void
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      accessToken: null,
      refreshToken: null,
      isAuthenticated: false,
      isLoading: false,
      
      login: async (email, password) => {
        set({ isLoading: true })
        try {
          const res = await authApi.login({ email, password })
          set({
            user: res.data.user,
            accessToken: res.data.tokens.accessToken,
            refreshToken: res.data.tokens.refreshToken,
            isAuthenticated: true,
          })
        } finally {
          set({ isLoading: false })
        }
      },
      
      register: async (email, password, username) => {
        set({ isLoading: true })
        try {
          const res = await authApi.register({ email, password, username })
          set({
            user: res.data.user,
            accessToken: res.data.tokens.accessToken,
            refreshToken: res.data.tokens.refreshToken,
            isAuthenticated: true,
          })
        } finally {
          set({ isLoading: false })
        }
      },
      
      logout: () => {
        set({
          user: null,
          accessToken: null,
          refreshToken: null,
          isAuthenticated: false,
        })
      },
      
      refreshToken: async () => {
        const currentRefreshToken = get().refreshToken
        if (!currentRefreshToken) return false
        
        try {
          const res = await authApi.refresh(currentRefreshToken)
          set({
            accessToken: res.data.accessToken,
            refreshToken: res.data.refreshToken,
          })
          return true
        } catch {
          get().logout()
          return false
        }
      },
      
      setUser: (user) => set({ user }),
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        accessToken: state.accessToken,
        refreshToken: state.refreshToken,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
)
```

#### 任务状态

```ts
// src/stores/taskStore.ts
import { create } from 'zustand'
import { taskApi } from '@/api'

interface TaskState {
  tasks: Task[]
  selectedTask: Task | null
  isLoading: boolean
  filter: TaskFilter
  
  fetchTasks: (filter?: TaskFilter) => Promise<void>
  selectTask: (id: string) => Promise<void>
  createTask: (data: CreateTaskRequest) => Promise<void>
  updateTaskStatus: (id: string, status: TaskStatus) => Promise<void>
  setFilter: (filter: TaskFilter) => void
}

export const useTaskStore = create<TaskState>((set, get) => ({
  tasks: [],
  selectedTask: null,
  isLoading: false,
  filter: { status: 'all', page: 1, pageSize: 20 },
  
  fetchTasks: async (filter) => {
    set({ isLoading: true })
    try {
      const finalFilter = filter || get().filter
      const res = await taskApi.list(finalFilter)
      set({ tasks: res.data.items, filter: finalFilter })
    } finally {
      set({ isLoading: false })
    }
  },
  
  selectTask: async (id) => {
    const res = await taskApi.getDetail(id)
    set({ selectedTask: res.data })
  },
  
  createTask: async (data) => {
    await taskApi.create(data)
    get().fetchTasks()
  },
  
  updateTaskStatus: async (id, status) => {
    await taskApi.updateStatus(id, status)
    get().fetchTasks()
  },
  
  setFilter: (filter) => set({ filter }),
}))
```

### 2.4 WebSocket实时通信

#### Socket连接管理

```ts
// src/hooks/useWebSocket.ts
import { useEffect, useRef, useCallback } from 'react'
import { io, Socket } from 'socket.io-client'
import { useAuthStore } from '@/stores/authStore'

interface WsEvent {
  type: string
  data: any
  timestamp: number
}

export function useWebSocket(
  channels: string[],
  onMessage: (event: WsEvent) => void
) {
  const socketRef = useRef<Socket | null>(null)
  const accessToken = useAuthStore((s) => s.accessToken)
  
  useEffect(() => {
    if (!accessToken) return
    
    // 建立连接
    const socket = io('/', {
      auth: { token: accessToken },
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: 5,
    })
    
    socketRef.current = socket
    
    // 连接成功
    socket.on('connect', () => {
      console.log('WebSocket connected:', socket.id)
      socket.emit('subscribe', { channels })
    })
    
    // 接收消息
    socket.on('event', (data: WsEvent) => {
      onMessage(data)
    })
    
    // 重新连接
    socket.on('reconnect', () => {
      console.log('WebSocket reconnected')
      socket.emit('subscribe', { channels })
    })
    
    // 断开连接
    socket.on('disconnect', () => {
      console.log('WebSocket disconnected')
    })
    
    return () => {
      socket.disconnect()
    }
  }, [accessToken, channels, onMessage])
  
  // 订阅新频道
  const subscribe = useCallback((newChannels: string[]) => {
    socketRef.current?.emit('subscribe', { channels: newChannels })
  }, [])
  
  // 取消订阅
  const unsubscribe = useCallback((removeChannels: string[]) => {
    socketRef.current?.emit('unsubscribe', { channels: removeChannels })
  }, [])
  
  // 发送消息
  const emit = useCallback((event: string, data: any) => {
    socketRef.current?.emit(event, data)
  }, [])
  
  return { subscribe, unsubscribe, emit }
}
```

#### 在页面中使用

```tsx
// src/pages/tasks/TaskDetail/index.tsx
import { useState, useCallback, useEffect } from 'react'
import { useParams } from 'react-router-dom'
import { useWebSocket } from '@/hooks/useWebSocket'
import { useTaskStore } from '@/stores/taskStore'

export default function TaskDetail() {
  const { id } = useParams<{ id: string }>()!
  const [task, setTask] = useState<Task | null>(null)
  const { selectTask } = useTaskStore()
  
  // WebSocket事件处理
  const handleWsEvent = useCallback((event: WsEvent) => {
    if (event.type === 'task.progress_updated') {
      setTask((prev) => 
        prev ? { ...prev, progress: event.data.progress } : null
      )
    }
    
    if (event.type === 'task.status_changed') {
      setTask((prev) => 
        prev ? { ...prev, status: event.data.status } : null
      )
    }
  }, [])
  
  // 订阅任务频道
  const { subscribe, unsubscribe } = useWebSocket(
    [`task.${id}`],
    handleWsEvent
  )
  
  // 加载任务详情
  useEffect(() => {
    const loadTask = async () => {
      const res = await selectTask(id)
      setTask(res)
    }
    loadTask()
  }, [id, selectTask])
  
  // 清理订阅
  useEffect(() => {
    return () => {
      unsubscribe([`task.${id}`])
    }
  }, [id, unsubscribe])
  
  if (!task) return <LoadingSkeleton />
  
  return (
    <div className="space-y-6">
      <TaskHeader task={task} />
      <TaskProgressBar progress={task.progress} />
      <TaskStepsList steps={task.steps} />
      <TaskActions task={task} />
    </div>
  )
}
```

### 2.5 页面组件示例

#### 驾驶舱首页

```tsx
// src/pages/dashboard/Dashboard/index.tsx
import { useEffect } from 'react'
import { useQuery } from '@tanstack/react-query'
import { dashboardApi } from '@/api'
import { KPICards } from './components/KPICards'
import { TaskProgress } from './components/TaskProgress'
import { ActivityFeed } from './components/ActivityFeed'

export default function Dashboard() {
  const { data, isLoading, refetch } = useQuery({
    queryKey: ['dashboard'],
    queryFn: dashboardApi.getOverview,
    refetchInterval: 30000, // 30秒自动刷新
  })
  
  if (isLoading) return <DashboardSkeleton />
  
  return (
    <div className="space-y-6 p-6">
      {/* KPI卡片行 */}
      <KPICards
        todayTasks={data?.todayTasks}
        successRate={data?.successRate}
        teamEfficiency={data?.teamEfficiency}
        activeEmployees={data?.activeEmployees}
      />
      
      <div className="grid grid-cols-3 gap-6">
        {/* 左侧：任务进度和快捷命令 */}
        <div className="col-span-2 space-y-6">
          <TaskProgress tasks={data?.runningTasks} />
          <QuickCommand onCommand={handleQuickCommand} />
        </div>
        
        {/* 右侧：预警和活动流 */}
        <div className="space-y-6">
          <AlertPanel alerts={data?.alerts} />
          <ActivityFeed activities={data?.activities} />
        </div>
      </div>
    </div>
  )
}
```

---

## 三、关键集成点

### 3.1 后端与前端的API契约

#### 统一响应格式

```go
// backend
type ApiResponse<T> struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Data    T      `json:"data"`
}
```

```ts
// frontend
interface ApiResponse<T> {
  code: number
  message: string
  data: T
}
```

### 3.2 事件通道设计

| 频道 | 用途 | 事件类型 |
|------|------|--------|
| `task.*` | 任务进度 | progress_updated, status_changed |
| `employee.*` | 员工状态 | status_changed, skill_equipped |
| `company.*` | 公司事件 | member_joined, balance_updated |
| `notification.*` | 系统通知 | alert_created, message_sent |

---

## 四、部署与运维

### 4.1 Docker Compose完整配置

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: unlimited
      POSTGRES_PASSWORD: password
      POSTGRES_DB: unlimited_corp
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  temporal:
    image: temporalio/auto-setup:latest
    environment:
      DB: postgresql
      DB_PORT: 5432
      POSTGRES_USER: unlimited
      POSTGRES_PWD: password
    depends_on:
      - postgres
    ports:
      - "7233:7233"

  temporal-ui:
    image: temporalio/ui:latest
    environment:
      TEMPORAL_ADDRESS: temporal:7233
    depends_on:
      - temporal
    ports:
      - "8081:8080"

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: postgres://unlimited:password@postgres:5432/unlimited_corp
      REDIS_URL: redis://redis:6379
      TEMPORAL_ADDRESS: temporal:7233
    depends_on:
      - postgres
      - redis
      - temporal
    ports:
      - "8080:8080"

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    depends_on:
      - backend

volumes:
  postgres_data:
```

### 4.2 Dockerfile

```dockerfile
# backend/Dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o backend ./cmd/server

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/backend .
EXPOSE 8080
CMD ["./backend"]
```

```dockerfile
# frontend/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm install

COPY . .
RUN pnpm build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

---

## 五、测试策略

### 5.1 后端单元测试

```go
// backend/internal/service/task_scheduler_test.go
func TestScheduleTask(t *testing.T) {
    // 准备测试数据
    task := &domain.Task{
        ID: "task_001",
        RequiredSkillCardID: "skc_001",
        Priority: 2,
    }
    
    // 模拟员工repository
    mockEmpRepo := mockEmployeeRepository{
        employees: []*domain.Employee{
            {ID: "emp_001", Status: domain.StatusIdle},
            {ID: "emp_002", Status: domain.StatusWorking},
        },
    }
    
    // 执行调度
    scheduler := NewTaskScheduler(&mockEmpRepo, nil, nil)
    err := scheduler.Schedule(context.Background(), task)
    
    // 验证
    assert.NoError(t, err)
    assert.Equal(t, "emp_001", task.AssignedEmployeeID)
}
```

### 5.2 前端组件测试

```tsx
// frontend/src/__tests__/components/TaskCard.test.tsx
import { render, screen } from '@testing-library/react'
import { TaskCard } from '@/components/business/TaskCard'

describe('TaskCard', () => {
  it('should render task card with correct information', () => {
    const task = {
      id: 'task_001',
      name: 'Test Task',
      status: 'running',
      progress: 50,
    }
    
    render(<TaskCard task={task} onClick={() => {}} />)
    
    expect(screen.getByText('Test Task')).toBeInTheDocument()
    expect(screen.getByText(/50%/)).toBeInTheDocument()
  })
})
```

---

## 六、监控与告警

### 6.1 日志策略

```go
// backend/internal/infrastructure/logger/logger.go
type Logger struct {
    zap.Logger
}

func (l *Logger) Infof(msg string, args ...interface{}) {
    l.Sugar().Infof(msg, args...)
}

func (l *Logger) Warnf(msg string, args ...interface{}) {
    l.Sugar().Warnf(msg, args...)
}

func (l *Logger) Errorf(msg string, args ...interface{}) {
    l.Sugar().Errorf(msg, args...)
}
```

### 6.2 性能指标

```go
// 记录关键操作的执行时间
func (s *TaskScheduler) Schedule(ctx context.Context, task *domain.Task) error {
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.metrics.SchedulingDuration.Observe(duration.Seconds())
    }()
    
    // ... 调度逻辑
}
```

---

**文档完成时间**: 2025-12-08  
**下一步**: 开始M3和M4的并行开发

